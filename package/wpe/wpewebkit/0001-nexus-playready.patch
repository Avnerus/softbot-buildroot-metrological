diff --git a/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.cpp b/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.cpp
index 0d13ee3..7282679 100644
--- a/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.cpp
@@ -42,6 +42,234 @@ G_LOCK_DEFINE_STATIC (pr_decoder_lock);
 
 namespace WebCore {
 
+#if defined(BCM_PLAYREADY)
+
+void PlayreadySession::Initialize()
+{
+    DRM_Prdy_Init_t settings;
+    m_oDecryptContext.pKeyContext = &m_oDecryptContextKey;
+
+    DRM_Prdy_GetDefaultParamSettings(&settings);
+    settings.hdsFileName = "/tmp/wpe.hds";
+
+    m_prdyHandle = DRM_Prdy_Initialize(&settings);
+
+
+
+    if (m_prdyHandle == nullptr) {
+        m_eKeyState = KEY_ERROR;
+        GST_ERROR("Playready initialization failed");
+    } else {
+      int rc = NEXUS_Memory_Allocate(m_DecryptBufferSize, nullptr, reinterpret_cast<void**>(&m_DecryptBuffer));
+      if( rc != 0 ) {
+        m_eKeyState = KEY_ERROR;
+        GST_ERROR("Playready initialization failed: NEXUS_Memory_Allocate");
+      } else {
+        printf("Playready initialized \n");    
+      }
+      
+    }
+}
+
+void PlayreadySession::Deinitialize()
+{
+
+    if(m_prdyHandle != nullptr) 
+      DRM_Prdy_Uninitialize(m_prdyHandle);
+
+    if (m_DecryptBuffer != nullptr)
+      NEXUS_Memory_Free(m_DecryptBuffer);
+
+
+}
+
+//
+// Expected synchronisation from caller. This method is not thread-safe!
+//
+RefPtr<Uint8Array> PlayreadySession::playreadyGenerateKeyRequest(Uint8Array* initData, const String& customData, String& destinationURL, unsigned short& errorCode, uint32_t& systemCode)
+{
+    RefPtr<Uint8Array> result;
+    DRM_Prdy_Error_e dr = DRM_Prdy_fail;
+
+    GST_MEMDUMP("init data", initData->data(), initData->byteLength());
+
+    // The current state MUST be KEY_INIT otherwise error out.
+    if ( (m_eKeyState == KEY_INIT) && ((dr = DRM_Prdy_Content_SetProperty(
+          m_prdyHandle,
+          DRM_Prdy_contentSetProperty_eAutoDetectHeader,
+          initData->data(),
+          initData->byteLength())) == DRM_Prdy_ok) ) {
+
+        unsigned int cbChallenge = 0;
+        unsigned int cchSilentURL = 0;
+
+        DRM_Prdy_Reader_Bind(m_prdyHandle, &m_oDecryptContext);
+
+        // Try to figure out the size of the license acquisition
+        // challenge to be returned.
+        if ( (dr = DRM_Prdy_Get_Buffer_Size(
+              m_prdyHandle,
+              DRM_Prdy_getBuffer_licenseAcq_challenge,
+              customData.isEmpty() ? nullptr : reinterpret_cast<const uint8_t*>(customData.utf8().data()),
+              customData.length(),
+              &cchSilentURL,
+              &cbChallenge)) == DRM_Prdy_ok ) {
+
+            char* pbChallenge = nullptr;
+            char* pchSilentURL = nullptr;
+
+            if (cchSilentURL > 0) {
+                pchSilentURL = reinterpret_cast<char *>(malloc(cchSilentURL + 1));
+                memset(pchSilentURL, 0, sizeof(cchSilentURL+1));
+            }
+
+            // Allocate buffer that is sufficient to store the license acquisition
+            // challenge.
+            if (cbChallenge > 0) {
+                pbChallenge = reinterpret_cast<char *>(malloc(cbChallenge+1));
+                memset(pbChallenge, 0, sizeof(cbChallenge+1));
+            }
+
+            // Supply a buffer to receive the license acquisition challenge.
+            if ( (dr = DRM_Prdy_LicenseAcq_GenerateChallenge(
+                     m_prdyHandle,
+                     customData.isEmpty() ? nullptr : reinterpret_cast<const char*>(customData.utf8().data()),
+                     customData.length(),
+                     pchSilentURL,
+                     &cchSilentURL,
+                     pbChallenge,
+                     &cbChallenge)) == DRM_Prdy_ok) {
+
+                result = Uint8Array::create( reinterpret_cast<const unsigned char *>(pbChallenge), cbChallenge);
+                destinationURL = String(pchSilentURL, cchSilentURL);
+                printf("destination URL : %s \n", destinationURL.utf8().data());
+
+                m_eKeyState = KEY_PENDING;
+                free(pbChallenge);
+                free(pchSilentURL);
+            }
+        }
+    }
+
+    systemCode = dr;
+
+    if (dr != DRM_Prdy_ok) {
+#if ENABLE(LEGACY_ENCRYPTED_MEDIA_V1) || ENABLE(LEGACY_ENCRYPTED_MEDIA)
+        errorCode = WebKitMediaKeyError::MEDIA_KEYERR_CLIENT;
+#endif
+    }
+    else {
+        errorCode = 0;
+    }
+ 
+    return result;
+}
+
+//
+// Expected synchronisation from caller. This method is not thread-safe!
+//
+bool PlayreadySession::playreadyProcessKey(Uint8Array* key, RefPtr<Uint8Array>&, unsigned short& errorCode, uint32_t& systemCode)
+{
+    DRM_Prdy_Error_e dr = DRM_Prdy_fail;
+    DRM_Prdy_License_Response_t oLicenseResponse = { DRM_Prdy_License_Protocol_Type_eUnknownProtocol, 0 };
+    DRM_Prdy_DecryptSettings_t pDecryptSettings;
+    uint8_t *m_pbKeyMessageResponse = key->data();
+    uint32_t m_cbKeyMessageResponse = key->byteLength();
+
+    GST_MEMDUMP("response received :", key->data(), key->byteLength());
+
+    if ( (m_pbKeyMessageResponse != nullptr) && (m_cbKeyMessageResponse > 0) && (m_eKeyState == KEY_PENDING) &&
+         ( (dr = DRM_Prdy_LicenseAcq_ProcessResponse(
+                 m_prdyHandle,
+                 reinterpret_cast<const char *>(m_pbKeyMessageResponse),
+                 m_cbKeyMessageResponse,
+                 &oLicenseResponse)) == DRM_Prdy_ok) &&
+         ( (dr = DRM_Prdy_Reader_Bind(
+                 m_prdyHandle,
+                 &m_oDecryptContext)) == DRM_Prdy_ok) ) {
+
+        printf("playreadyProcessKey did everything, DR result: %d \n", dr);
+
+        m_key = key->possiblySharedBuffer();
+        m_eKeyState = KEY_READY;
+    }
+
+    systemCode = dr;
+
+    if (dr != DRM_Prdy_ok) {
+#if ENABLE(LEGACY_ENCRYPTED_MEDIA_V1) || ENABLE(LEGACY_ENCRYPTED_MEDIA)
+        errorCode = WebKitMediaKeyError::MEDIA_KEYERR_CLIENT;
+#endif
+    }
+    else {
+        errorCode = 0;
+    }
+ 
+    return (dr == DRM_Prdy_ok);
+}
+
+int PlayreadySession::processPayload(const void* iv, uint32_t ivSize, void* payloadData, uint32_t payloadDataSize)
+{
+    DRM_Prdy_Error_e dr = DRM_Prdy_fail;
+    DRM_Prdy_AES_CTR_Info_t oAESContext;
+
+    if (sizeof(oAESContext.qwInitializationVector) >= ivSize) {
+        uint8_t* newBuffer = nullptr;
+        const uint8_t* source = reinterpret_cast<const uint8_t*>(iv);
+        uint8_t* destination = reinterpret_cast<uint8_t*>(&oAESContext.qwInitializationVector);
+
+        for (uint32_t index = 0; index < (ivSize / 2); index++) {
+            destination[index] = source[ivSize - index - 1];
+            destination[ivSize - index - 1] = source[index];
+        }
+
+      
+        oAESContext.qwBlockOffset = 0;
+        oAESContext.bByteOffset = 0;
+   
+        if (payloadDataSize >  m_DecryptBufferSize) {
+            int rc = NEXUS_Memory_Allocate(payloadDataSize, nullptr, reinterpret_cast<void**>(&newBuffer));
+            if( rc != 0 ) {
+                printf("[FAILED] %d  Transmitter - Failed to allocate memory for the cipher text for encryption test.\n",__LINE__);
+            }
+            else {              
+                memcpy(newBuffer, payloadData, payloadDataSize);
+            }
+        }
+
+        G_LOCK (pr_decoder_lock);
+
+        if (newBuffer != nullptr) {
+          m_DecryptBufferSize = payloadDataSize;
+          NEXUS_Memory_Free(m_DecryptBuffer);
+          m_DecryptBuffer = newBuffer;
+          printf("m_DecryptBufferSize to small, use larger buffer. newSize: %d \n", payloadDataSize);
+        }
+        else {
+            memcpy(m_DecryptBuffer, payloadData, payloadDataSize);
+        }
+
+        if ( (dr = DRM_Prdy_Reader_Decrypt(&m_oDecryptContext, &oAESContext, m_DecryptBuffer, payloadDataSize)) == DRM_Prdy_ok) {
+
+            memcpy(payloadData, m_DecryptBuffer, payloadDataSize);
+
+            if ( (!m_fCommit) && ((dr = DRM_Prdy_Reader_Commit(m_prdyHandle)) == DRM_Prdy_ok) )
+                m_fCommit = true;
+            
+        } else {
+          printf("Decrypt failed, dr: %d\n", dr);
+        }
+
+        G_UNLOCK (pr_decoder_lock);
+    } else {
+      printf("oAESContext.qwInitializationVector smaller than ivSize. %d %d \n", sizeof(oAESContext.qwInitializationVector), ivSize);
+    }
+
+    return (dr == DRM_Prdy_ok ? 0 : 1);
+}
+
+#else //NOT NEXUS
+
 // The default location of CDM DRM store.
 // /tmp/drmstore.dat
 const DRM_WCHAR g_rgwchCDMDrmStoreName[] = {WCHAR_CAST('/'), WCHAR_CAST('t'), WCHAR_CAST('m'), WCHAR_CAST('p'), WCHAR_CAST('/'),
@@ -53,16 +281,7 @@ const DRM_CONST_STRING g_dstrCDMDrmStoreName = CREATE_DRM_STRING(g_rgwchCDMDrmSt
 
 const DRM_CONST_STRING* g_rgpdstrRights[1] = {&g_dstrWMDRM_RIGHT_PLAYBACK};
 
-PlayreadySession::PlayreadySession(const Vector<uint8_t> &initData, const void* pipeline)
-    : m_key()
-    , m_poAppContext(nullptr)
-    , m_pbOpaqueBuffer(nullptr)
-    , m_pbRevocationBuffer(nullptr)
-    , m_eKeyState(KEY_INIT)
-    , m_fCommit(FALSE)
-    , m_sessionId(createCanonicalUUIDString())
-    , m_initData(initData)
-    , m_pipeline(pipeline)
+void PlayreadySession::Initialize()
 {
     DRM_RESULT dr = DRM_SUCCESS;
     DRM_ID oSessionID;
@@ -109,7 +328,7 @@ PlayreadySession::PlayreadySession(const Vector<uint8_t> &initData, const void*
     }
 }
 
-PlayreadySession::~PlayreadySession()
+void PlayreadySession::Deinitialize()
 {
     GST_DEBUG("Releasing resources");
 
@@ -318,6 +537,43 @@ ErrorExit:
     G_UNLOCK (pr_decoder_lock);
     return 1;
 }
-}
 
+#endif // NEXUS
+
+PlayreadySession::PlayreadySession(const Vector<uint8_t> &initData, const void* pipeline)
+    : m_key()
+
+#if defined(BCM_PLAYREADY)   
+
+    , m_prdyHandle(nullptr)
+    , m_oDecryptContext()
+    , m_oDecryptContextKey()
+    , m_DecryptBufferSize(100000)
+    , m_DecryptBuffer(nullptr)
+    , m_fCommit(false)
+
+
+#else
+    , m_poAppContext(nullptr)
+    , m_pbOpaqueBuffer(nullptr)
+    , m_pbRevocationBuffer(nullptr)
+    , m_fCommit(FALSE)
 #endif
+
+    , m_eKeyState(KEY_INIT)
+    , m_sessionId(createCanonicalUUIDString())
+    , m_initData(initData)
+    , m_pipeline(pipeline)
+{
+    Initialize();
+}
+
+PlayreadySession::~PlayreadySession()
+{
+    Deinitialize();
+}
+
+
+} // Namespace
+
+#endif // PLAYREADY
diff --git a/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.h b/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.h
index 68f354b..da06887 100644
--- a/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.h
+++ b/Source/WebCore/platform/graphics/gstreamer/eme/PlayreadySession.h
@@ -24,10 +24,16 @@
 
 #if USE(PLAYREADY)
 
+#if defined(BCM_PLAYREADY)
+#include <refsw/nexus_memory.h>
+#include <refsw/drm_prdy.h>
+#else
 #include <drmtypes.h>
 #include <drmcommon.h>
 #include <drmmanager.h>
 #include <drmmathsafe.h>
+#endif
+
 #undef __in
 #undef __out
 #include <runtime/Uint8Array.h>
@@ -73,6 +79,19 @@ protected:
     RefPtr<ArrayBuffer> m_key;
 
 private:
+    void Initialize();
+    void Deinitialize();
+
+#if defined(BCM_PLAYREADY)
+    DRM_Prdy_Handle_t m_prdyHandle;
+    DRM_Prdy_DecryptContext_t m_oDecryptContext;
+    DRM_Prdy_DecryptContextKey_t m_oDecryptContextKey;
+    uint32_t m_DecryptBufferSize;
+    uint8_t* m_DecryptBuffer;
+    bool m_fCommit;
+
+#else
+
     static DRM_RESULT DRM_CALL _PolicyCallback(const DRM_VOID* f_pvOutputLevelsData, DRM_POLICY_CALLBACK_TYPE f_dwCallbackType, const DRM_VOID* f_pv);
 
     DRM_APP_CONTEXT* m_poAppContext { nullptr };
@@ -82,10 +101,12 @@ private:
     DRM_DWORD m_cbOpaqueBuffer;
 
     DRM_BYTE* m_pbRevocationBuffer { nullptr };
-    KeyState m_eKeyState;
     DRM_CHAR m_rgchSessionID[CCH_BASE64_EQUIV(SIZEOF(DRM_ID)) + 1];
     DRM_BOOL m_fCommit;
 
+#endif
+
+    KeyState m_eKeyState;
     Lock m_prSessionMutex;
     String m_sessionId;
     Vector<uint8_t> m_initData;
